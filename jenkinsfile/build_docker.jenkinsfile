#!groovy

def resultBuild = true
def VERSION
def OTHER_VERSION
STATUS="Успешно"
properties([disableConcurrentBuilds()])

pipeline{
  agent{
    label 'docker_centos'
  }
  stages{
    stage("Очистка сборочной директории"){
      steps{
        deleteDir();
      }
    }
    stage("Клонирование GIT"){
      steps{
        echo "========== Cloning GIT =========="
        script{
          try{
            git 'ssh://bezpalko_p@10.10.199.35/opt/git/firelink/roschat-server_docker'
          }catch(err){
            currentBuild.result = "FAILURE"
            error("Невозможно выполниь клонированние из репозитория git")
          }
        }
      }
    }
    stage("Остановка старого контейнера"){
      steps{
        script{
          try{
            echo "========== Stop docker container =========="
            def exists_old_docker=fileExists '/tmp/build.other'
            OTHER_VERSION=readFile('/tmp/build.other').trim()
            if(exists_old_docker){
              sh "docker ps | grep roschat-server > /dev/null && docker container stop roschat-server_${OTHER_VERSION}"
            }
          }catch(err){
            currentBuild.result = "FAILURE"
            error("Не удалось остановить старый контейнер")
          }
        }
      }
    }
    stage("Сборка образа и запуск контейнера"){
      steps{
        script{
          VERSION=readFile('/tmp/build').trim()
          VERSION="${VERSION}_${BUILD_NUMBER}"
          try{
            echo "========== TAG for new docker =========="
            sh "echo TAG=${VERSION} > ${WORKSPACE}/.env"
            echo "========== Copy rpms =========="
            sh "test ! -d ${WORKSPACE}/rpms && cp -r /tmp/rpms ${WORKSPACE}"
            echo "========== Build docker image and run container =========="
            sh "docker-compose up -d"
          }catch(err){
            currentBuild.result = "FAILURE"
            error("Во время выполнения сборки/запуска была ошибка")
          }
        }
      }
    }
    stage("Установка ПО на сервер"){
      steps{
        script{
          try{
            echo "========== Install soft on docker container =========="
            sh "docker container exec roschat-server_${VERSION} /tmp/start_ansible_playbook.sh"
          }catch(e){
            resultBuild=false
          }
        }
      }
    }
    stage("Проверка успешности сборки сервера"){
      steps{
        script{
            if(!resultBuild){
              echo '========== Faild build docker image and start container =========='
              def exists_docker=sh script: "docker ps -a | grep roschat-server_${VERSION}", returnStdout: true
              if(exists_docker){
                sh "docker-compose down && docker rmi roschat-server:${VERSION}"
              }

              echo "========== Start old container =========="
              sh "echo TAG=${OTHER_VERSION} > ${WORKSPACE}/.env"
              sh "docker-compose up -d"
              sh "docker container exec roschat-server_${OTHER_VERSION} /tmp/start_ansible_playbook.sh"
            }
        }
      }
    }
    stage('Удаление метки для сборки образа'){
      steps{
        script{
          if(resultBuild){
            echo "========== Remove mark for build =========="
            sh "rm -f /tmp/build && echo ${VERSION} > /tmp/build.other"
          }
        }
      }
    }
  }
  post{
    always{
      script{
        if(!resultBuild){
          STATUS="Провал"
        }
        if(currentBuild.result != "SUCCESS"){
          STATUS="Провал"
        }
      }
      //emailext body: "Собираемая версия сервера - roschat-server:${VERSION} \n Результат сборки - ${STATUS}", subject: 'Сборка Росчат сервера', to: 'bezpalko', from: 'jenkins@ros.chat'
    }
    /*success{
      script{
        build(job: "roschat-server-testing",
          parameters:
          [string(name: 'VER', value: "${VERSION}")])
      }
    }*/
  }
}
